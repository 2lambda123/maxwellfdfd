
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ModalSrc</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-12-04"><meta name="DC.source" content="ModalSrc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ModalSrc</h1><!--introduction--><p>Concrete subclass of <a href="Source.html"><tt>Source</tt></a> representing an electric dipole distribution that generates a mode of a waveguide.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Construction</a></li><li><a href="#3">Note</a></li><li><a href="#4">Example</a></li><li><a href="#5">See Also</a></li></ul></div><h2>Description<a name="1"></a></h2><p><tt>ModalSrc</tt> is used to store the transverse <i>J</i>-field distribution on a plane to generate a mode of a waveguide.  The plane should be orthogonal to the axis of the waveguide.  The mode is calculated by an external mode solver.  To assist the mode solver to calculate the mode, users need to provide an estimate of the effective refractive constant of the mode to the constructor of <tt>ModalSrc</tt>.</p><h2>Construction<a name="2"></a></h2><pre>src = ModalSrc(normal_axis, intercept, neff_guess)
src = ModalSrc(normal_axis, intercept, neff_guess, KA)</pre><p><b>Input Arguments</b></p><div><ul><li><tt>normal_axis</tt>: direction normal to the plane over which the electric dipoles distribute.  It is also the axis of the waveguide.  It should be one of <tt>Axis.x</tt>, <tt>Axis.y</tt>, <tt>Axis.z</tt>.</li><li><tt>intercept</tt>: location of the plane in the <tt>normal_axis</tt> direction.</li><li><tt>neff_guess</tt>: estimate of the effective refractive index of the mode to calculate.</li><li><tt>KA</tt>: integral of the norm of the surface current density.  It indicates the strength of the mode amplitude.  If not assigned, the deault value <tt>KA = 1</tt> is used.</li></ul></div><h2>Note<a name="3"></a></h2><p>In the finite-difference grid, <tt>ModalSrc</tt> excites dipoles at the <i>E</i>-field points.  This poses a condition on <tt>intercept</tt> argument in the constructor: <tt>intercept</tt> should be at a dual grid point in the <tt>normal_axis</tt> direction. Therefore, make sure that <tt>intercept</tt> does not overlap with the locations of the vertices of <a href="Shape.html"><tt>Shape</tt></a> in the <tt>normal_axis</tt> direction; otherwise dynamic grid generation in <a href="moxwell_run.html"><tt>maxwell_run</tt></a> will fail.</p><h2>Example<a name="4"></a></h2><pre class="language-matlab"><span class="comment">% Create an instance of PointSrc.</span>
src =  ModalSrc(Axis.y, -1000, 1.0);  <span class="comment">% y = -1000 should not be primary grid point</span>
</pre><pre class="language-matlab"><span class="comment">% Use the constructed src in maxwell_run().</span>
[E, H] = maxwell_run({INITIAL ARGUMENTS}, <span class="string">'SRC'</span>, src);
</pre><h2>See Also<a name="5"></a></h2><p><a href="Plane.html"><tt>PlaneSrc</tt></a>, <a href="TFSFPlaneSrc.html"><tt>TFSFPlaneSrc</tt></a>, <a href="ModalSrc.html"><tt>ModalSrc</tt></a>, <a href="maxwell_run.html"><tt>maxwell_run</tt></a></p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ModalSrc
% Concrete subclass of <Source.html |Source|> representing an electric dipole
% distribution that generates a mode of a waveguide.

%%% Description
% |ModalSrc| is used to store the transverse _J_-field distribution on a plane
% to generate a mode of a waveguide.  The plane should be orthogonal to the axis
% of the waveguide.  The mode is calculated by an external mode solver.  To
% assist the mode solver to calculate the mode, users need to provide an
% estimate of the effective refractive constant of the mode to the constructor
% of |ModalSrc|.

%%% Construction
%  src = ModalSrc(normal_axis, intercept, neff_guess)
%  src = ModalSrc(normal_axis, intercept, neff_guess, KA)
% 
% *Input Arguments*
%
% * |normal_axis|: direction normal to the plane over which the electric dipoles
% distribute.  It is also the axis of the waveguide.  It should be one of
% |Axis.x|, |Axis.y|, |Axis.z|.
% * |intercept|: location of the plane in the |normal_axis| direction.
% * |neff_guess|: estimate of the effective refractive index of the mode to
% calculate. 
% * |KA|: integral of the norm of the surface current density.  It indicates the
% strength of the mode amplitude.  If not assigned, the deault value |KA = 1| is
% used.

%%% Note
% In the finite-difference grid, |ModalSrc| excites dipoles at the _E_-field
% points.  This poses a condition on |intercept| argument in the constructor:
% |intercept| should be at a dual grid point in the |normal_axis| direction.
% Therefore, make sure that |intercept| does not overlap with the locations of
% the vertices of <Shape.html |Shape|> in the |normal_axis| direction; otherwise
% dynamic grid generation in <moxwell_run.html |maxwell_run|> will fail.

%%% Example
%   % Create an instance of PointSrc.
%   src =  ModalSrc(Axis.y, -1000, 1.0);  % y = -1000 should not be primary grid point
%
%   % Use the constructed src in maxwell_run().
%   [E, H] = maxwell_run({INITIAL ARGUMENTS}, 'SRC', src);

%%% See Also
% <Plane.html |PlaneSrc|>, <TFSFPlaneSrc.html |TFSFPlaneSrc|>, <ModalSrc.html
% |ModalSrc|>, <maxwell_run.html |maxwell_run|>

classdef ModalSrc < Source
	
	properties (SetAccess = immutable)
		normal_axis  % plane normal axis: one of Axis.x, Axis.y, Axis.z
		intercept  % intercept between plane and normal axis
		KA  % surface integral of surface current density K; for z-normal plane, volume integral of (|Jx|+|Jy|)
		neff_guess;  % estimated effective refractive index
	end
	
	properties (SetAccess = private)
		grid2d  % instance of Grid2d
		Jh  % J in horizontal direction on this plane: Jx for normal == z
		Jv  % J in vertical direction on this plane: Jy for normal == z
		neff  % effective n
	end
	
	methods
		function this = ModalSrc(normal_axis, intercept, neff_guess, KA)
			chkarg(istypesizeof(normal_axis, 'Axis'), ...
				'"normal_axis" should be instance of Axis.');
			chkarg(istypesizeof(intercept, 'real'), '"intercept" should be real.');
			chkarg(istypesizeof(neff_guess, 'complex'), '"neff" should be complex.');
			
			if nargin < 4  % no KA
				KA = 1.0;
			end
			chkarg(istypesizeof(KA, 'real'), '"KA" should be real.');
			
			l = cell(Axis.count, GK.count);
			l{normal_axis, GK.dual} = intercept;
			plane = Plane(normal_axis, intercept);
			this = this@Source(l, plane);
			
			this.normal_axis = normal_axis;
			this.intercept = intercept;
			this.neff_guess = neff_guess;
			this.KA = KA;
			this.Jh = [];
			this.Jv = [];
		end
		
		function setJ(this, neff, Jh, Jv, grid3d)
			chkarg(istypesizeof(neff, 'complex'), '"neff" should be complex.');
			this.neff = neff;
			
			chkarg(istypesizeof(grid3d, 'Grid3d'), '"grid3d" should be instance of Grid3d.');
			this.grid2d = Grid2d(grid3d, this.normal_axis);

			Nh = this.grid2d.N(Dir.h);
			Nv = this.grid2d.N(Dir.v);
			
			assert(istypesizeof(Jh, 'complex', [Nh Nv]), '"Jh" should be %d-by-%d matrix with complex elements.', Nh, Nv);
			assert(istypesizeof(Jv, 'complex', [Nh Nv]), '"Jv" should be %d-by-%d matrix with complex elements.', Nh, Nv);

			this.Jh = Jh;
			this.Jv = Jv;
		end
		
		function [index_cell, Jw_patch] = generate_kernel(this, w_axis, grid3d)
			assert(~isempty(this.Jh) && ~isempty(this.Jv), '"Jh" and "Jv" are not set in this ModalSrc.');
			index_cell = cell(1, Axis.count);
			if w_axis == this.normal_axis
				Jw_patch = [];
			else
				g2d = Grid2d(grid3d, this.normal_axis);
				assert(isequal(g2d, this.grid2d), ...
					'%s-normal cross section of "grid3d" is different from the one set with Jh and Jv.', char(this.normal_axis));

				h = this.grid2d.axis(Dir.h);
				v = this.grid2d.axis(Dir.v);
				n = this.normal_axis;
				
				g = GK.dual;
				ind_n = ismembc2(this.intercept, grid3d.l{n,g});
				if ind_n == 0
					[~, ind_n] = min(abs(grid3d.l{n,g} - this.intercept));
					warning('FDS:srcAssign', ...
						['%s grid in %s-axis of "grid3d" does not have location %e of this %s; ', ...
						'closest grid vertex at %e will be taken instead.'], ...
						char(g), char(n), this.intercept, class(this), grid3d.l{n,g}(ind_n));
				end
				
				% Set index_cell.
				Nh = this.grid2d.N(Dir.h);
				Nv = this.grid2d.N(Dir.v);
				index_cell{n} = ind_n;
				index_cell{h} = 1:Nh;
				index_cell{v} = 1:Nv;
				
				% Set Jw_patch.
				dn = grid3d.dl{n,g}(ind_n);
				dh_prim = grid3d.dl{h, GK.prim};
				dh_dual = grid3d.dl{h, GK.dual};
				dv_prim = grid3d.dl{v, GK.prim};
				dv_dual = grid3d.dl{v, GK.dual};
				
				dVh = dn .* (dh_prim.' * dv_dual);
				dVv = dn .* (dh_dual.' * dv_prim);
				
				KA_curr = abs(this.Jh) .* dVh + abs(this.Jv) .* dVv;
				KA_curr = sum(KA_curr(:));
				norm_factor = this.KA/KA_curr;  % normalization factor
				
				if w_axis == h
					Jw_patch = norm_factor .* this.Jh;
				else
					assert(w_axis == v);
					Jw_patch = norm_factor .* this.Jv;
				end
				
% 				if h > v  % h == Axis.z and v == Axis.x if this.normal_axis == Axis.y
% 					Jw_patch = permute(Jw_patch, int([Dir.v, Dir.h]));
% 				end
				Jw_patch = ipermute(Jw_patch, int([h v n]));
			end
		end
	end
	
end


##### SOURCE END #####
--></body></html>